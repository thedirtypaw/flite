{"version":3,"file":"util.slice-blocks.cjs","sources":["../../src/internal-utils/asserters.ts","../../src/internal-utils/parse-blocks.ts","../../src/utils/util.is-keyed-segment.ts","../../src/utils/util.block-offset.ts","../../src/utils/util.get-block-end-point.ts","../../src/utils/util.get-block-start-point.ts","../../src/utils/util.get-text-block-text.ts","../../src/utils/util.is-empty-text-block.ts","../../src/utils/util.is-equal-selection-points.ts","../../src/utils/util.is-span.ts","../../src/utils/util.reverse-selection.ts","../../src/utils/util.slice-blocks.ts"],"sourcesContent":["import type {TypedObject} from '@sanity/types'\n\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n","import type {\n  PortableTextBlock,\n  PortableTextListBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n  TypedObject,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isTypedObject} from './asserters'\n\nexport function parseBlocks({\n  context,\n  blocks,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  blocks: unknown\n  options: {\n    refreshKeys: boolean\n  }\n}): Array<PortableTextBlock> {\n  if (!Array.isArray(blocks)) {\n    return []\n  }\n\n  return blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({context, block, options})\n\n    return parsedBlock ? [parsedBlock] : []\n  })\n}\n\nexport function parseBlock({\n  context,\n  block,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  block: unknown\n  options: {\n    refreshKeys: boolean\n  }\n}): PortableTextBlock | undefined {\n  return (\n    parseTextBlock({block, context, options}) ??\n    parseBlockObject({blockObject: block, context, options})\n  )\n}\n\nexport function parseBlockObject({\n  blockObject,\n  context,\n  options,\n}: {\n  blockObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(blockObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.blockObjects.find(\n    ({name}) => name === blockObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: blockObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function isListBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: unknown,\n): block is PortableTextListBlock {\n  return (\n    isTextBlock(context, block) &&\n    block.level !== undefined &&\n    block.listItem !== undefined\n  )\n}\n\nexport function isTextBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: unknown,\n): block is PortableTextTextBlock {\n  return (\n    parseTextBlock({\n      block,\n      context: {schema: context.schema, keyGenerator: () => ''},\n      options: {refreshKeys: false},\n    }) !== undefined\n  )\n}\n\nexport function parseTextBlock({\n  block,\n  context,\n  options,\n}: {\n  block: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextTextBlock | undefined {\n  if (!isTypedObject(block)) {\n    return undefined\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return undefined\n  }\n\n  const _key = options.refreshKeys\n    ? context.keyGenerator()\n    : typeof block._key === 'string'\n      ? block._key\n      : context.keyGenerator()\n\n  const unparsedMarkDefs: Array<unknown> = Array.isArray(block.markDefs)\n    ? block.markDefs\n    : []\n  const markDefKeyMap = new Map<string, string>()\n  const markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef)) {\n      return []\n    }\n\n    const schemaType = context.schema.annotations.find(\n      ({name}) => name === markDef._type,\n    )\n\n    if (!schemaType) {\n      return []\n    }\n\n    if (typeof markDef._key !== 'string') {\n      // If the `markDef` doesn't have a `_key` then we don't know what spans\n      // it belongs to and therefore we have to discard it.\n      return []\n    }\n\n    const parsedAnnotation = parseObject({\n      object: markDef,\n      context: {\n        schemaType,\n        keyGenerator: context.keyGenerator,\n      },\n      options,\n    })\n\n    if (!parsedAnnotation) {\n      return []\n    }\n\n    markDefKeyMap.set(markDef._key, parsedAnnotation._key)\n\n    return [parsedAnnotation]\n  })\n\n  const unparsedChildren: Array<unknown> = Array.isArray(block.children)\n    ? block.children\n    : []\n\n  const children = unparsedChildren\n    .map(\n      (child) =>\n        parseSpan({span: child, context, markDefKeyMap, options}) ??\n        parseInlineObject({inlineObject: child, context, options}),\n    )\n    .filter((child) => child !== undefined)\n\n  const parsedBlock: PortableTextTextBlock = {\n    _type: context.schema.block.name,\n    _key,\n    children:\n      children.length > 0\n        ? children\n        : [\n            {\n              _key: context.keyGenerator(),\n              _type: context.schema.span.name,\n              text: '',\n              marks: [],\n            },\n          ],\n    markDefs,\n  }\n\n  if (\n    typeof block.style === 'string' &&\n    context.schema.styles.find((style) => style.name === block.style)\n  ) {\n    parsedBlock.style = block.style\n  } else {\n    const defaultStyle = context.schema.styles.at(0)?.name\n\n    if (defaultStyle !== undefined) {\n      parsedBlock.style = defaultStyle\n    } else {\n      console.error('Expected default style')\n    }\n  }\n\n  if (\n    typeof block.listItem === 'string' &&\n    context.schema.lists.find((list) => list.name === block.listItem)\n  ) {\n    parsedBlock.listItem = block.listItem\n  }\n\n  if (typeof block.level === 'number') {\n    parsedBlock.level = block.level\n  }\n\n  return parsedBlock\n}\n\nexport function isSpan(\n  context: Pick<EditorContext, 'schema'>,\n  child: unknown,\n): child is PortableTextSpan {\n  return (\n    parseSpan({\n      span: child,\n      markDefKeyMap: new Map(),\n      context: {schema: context.schema, keyGenerator: () => ''},\n      options: {refreshKeys: false},\n    }) !== undefined\n  )\n}\n\nexport function parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  span: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {refreshKeys: boolean}\n}): PortableTextSpan | undefined {\n  if (!isTypedObject(span)) {\n    return undefined\n  }\n\n  // In reality, the span schema name is always 'span', but we only the check here anyway\n  if (span._type !== context.schema.span.name || span._type !== 'span') {\n    return undefined\n  }\n\n  const unparsedMarks: Array<unknown> = Array.isArray(span.marks)\n    ? span.marks\n    : []\n  const marks = unparsedMarks.flatMap((mark) => {\n    if (typeof mark !== 'string') {\n      return []\n    }\n\n    const markDefKey = markDefKeyMap.get(mark)\n\n    if (markDefKey !== undefined) {\n      return [markDefKey]\n    }\n\n    if (\n      context.schema.decorators.some((decorator) => decorator.name === mark)\n    ) {\n      return [mark]\n    }\n\n    return []\n  })\n\n  return {\n    _type: 'span',\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof span._key === 'string'\n        ? span._key\n        : context.keyGenerator(),\n    text: typeof span.text === 'string' ? span.text : '',\n    marks,\n  }\n}\n\nexport function parseInlineObject({\n  inlineObject,\n  context,\n  options,\n}: {\n  inlineObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(inlineObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.inlineObjects.find(\n    ({name}) => name === inlineObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: inlineObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function parseAnnotation({\n  annotation,\n  context,\n  options,\n}: {\n  annotation: TypedObject\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(annotation)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.annotations.find(\n    ({name}) => name === annotation._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: annotation,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nfunction parseObject({\n  object,\n  context,\n  options,\n}: {\n  object: TypedObject\n  context: Pick<EditorContext, 'keyGenerator'> & {\n    schemaType: EditorSchema['blockObjects'][0]\n  }\n  options: {refreshKeys: boolean}\n}): PortableTextObject {\n  // Validates all props on the object and only takes those that match\n  // the name of a field\n  const values = context.schemaType.fields.reduce<Record<string, unknown>>(\n    (fieldValues, field) => {\n      const fieldValue = object[field.name]\n\n      if (fieldValue !== undefined) {\n        fieldValues[field.name] = fieldValue\n      }\n\n      return fieldValues\n    },\n    {},\n  )\n\n  return {\n    _type: context.schemaType.name,\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof object._key === 'string'\n        ? object._key\n        : context.keyGenerator(),\n    ...values,\n  }\n}\n","import type {KeyedSegment} from '@sanity/types'\n\n/**\n * @public\n */\nexport function isKeyedSegment(segment: unknown): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n","import type {KeyedSegment} from '@sanity/types'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  context,\n  blockOffset,\n  direction,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint:\n    | {path: [KeyedSegment, 'children', KeyedSegment]; offset: number}\n    | undefined\n  let skippedInlineObject = false\n\n  for (const block of context.value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (direction === 'forward') {\n        if (!isSpan(context, child)) {\n          continue\n        }\n\n        if (offsetLeft <= child.text.length) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: offsetLeft,\n          }\n          break\n        }\n\n        offsetLeft -= child.text.length\n\n        continue\n      }\n\n      if (!isSpan(context, child)) {\n        skippedInlineObject = true\n        continue\n      }\n\n      if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n        if (skippedInlineObject) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: 0,\n          }\n        }\n        break\n      }\n\n      if (offsetLeft > child.text.length) {\n        offsetLeft -= child.text.length\n        continue\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n\n        offsetLeft -= child.text.length\n\n        if (offsetLeft !== 0) {\n          break\n        }\n      }\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const spanKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of context.value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isSpan(context, child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getBlockEndPoint({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: {\n    node: PortableTextBlock\n    path: [KeyedSegment]\n  }\n}): EditorSelectionPoint {\n  if (isTextBlock(context, block.node)) {\n    const lastChild = block.node.children[block.node.children.length - 1]\n\n    if (lastChild) {\n      return {\n        path: [...block.path, 'children', {_key: lastChild._key}],\n        offset: isSpan(context, lastChild) ? lastChild.text.length : 0,\n      }\n    }\n  }\n\n  return {\n    path: block.path,\n    offset: 0,\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getBlockStartPoint({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: {\n    node: PortableTextBlock\n    path: [KeyedSegment]\n  }\n}): EditorSelectionPoint {\n  if (isTextBlock(context, block.node)) {\n    return {\n      path: [...block.path, 'children', {_key: block.node.children[0]._key}],\n      offset: 0,\n    }\n  }\n\n  return {\n    path: block.path,\n    offset: 0,\n  }\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\n\n/**\n * @public\n */\nexport function getTextBlockText(block: PortableTextTextBlock) {\n  return block.children.map((child) => child.text ?? '').join('')\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {getTextBlockText} from './util.get-text-block-text'\n\n/**\n * @public\n */\nexport function isEmptyTextBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: PortableTextBlock,\n) {\n  if (!isTextBlock(context, block)) {\n    return false\n  }\n\n  const onlyText = block.children.every((child) => isSpan(context, child))\n  const blockText = getTextBlockText(block)\n\n  return onlyText && blockText === ''\n}\n","import type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function isEqualSelectionPoints(\n  a: EditorSelectionPoint,\n  b: EditorSelectionPoint,\n) {\n  return (\n    a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path)\n  )\n}\n","import type {PortableTextChild, PortableTextSpan} from '@sanity/types'\nimport type {EditorContext} from '..'\n\n/**\n * @public\n */\nexport function isSpan(\n  context: Pick<EditorContext, 'schema'>,\n  child: PortableTextChild,\n): child is PortableTextSpan {\n  return child._type === context.schema.span.name\n}\n","import type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport function reverseSelection<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n>(selection: TEditorSelection): TEditorSelection {\n  if (!selection) {\n    return selection\n  }\n\n  if (selection.backward) {\n    return {\n      anchor: selection.focus,\n      focus: selection.anchor,\n      backward: false,\n    } as TEditorSelection\n  }\n\n  return {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: true,\n  } as TEditorSelection\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorContext} from '..'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function sliceBlocks({\n  context,\n  blocks,\n}: {\n  context: Pick<EditorContext, 'schema' | 'selection'>\n  blocks: Array<PortableTextBlock>\n}): Array<PortableTextBlock> {\n  const slice: Array<PortableTextBlock> = []\n\n  if (!context.selection) {\n    return slice\n  }\n\n  let startBlock: PortableTextBlock | undefined\n  const middleBlocks: PortableTextBlock[] = []\n  let endBlock: PortableTextBlock | undefined\n\n  const startPoint = context.selection.backward\n    ? context.selection.focus\n    : context.selection.anchor\n  const endPoint = context.selection.backward\n    ? context.selection.anchor\n    : context.selection.focus\n\n  const startBlockKey = isKeyedSegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeyedSegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n  const startChildKey = isKeyedSegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endChildKey = isKeyedSegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return slice\n  }\n\n  for (const block of blocks) {\n    if (!isTextBlock(context, block)) {\n      if (block._key === startBlockKey && block._key === endBlockKey) {\n        startBlock = block\n        break\n      }\n    }\n\n    if (block._key === startBlockKey) {\n      if (!isTextBlock(context, block)) {\n        startBlock = block\n        continue\n      }\n\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if (isSpan(context, child)) {\n              const text =\n                child._key === endChildKey\n                  ? child.text.slice(startPoint.offset, endPoint.offset)\n                  : child.text.slice(startPoint.offset)\n\n              startBlock = {\n                ...block,\n                children: [\n                  {\n                    ...child,\n                    text,\n                  },\n                ],\n              }\n            } else {\n              startBlock = {\n                ...block,\n                children: [child],\n              }\n            }\n\n            if (startChildKey === endChildKey) {\n              break\n            }\n            continue\n          }\n\n          if (startBlock && isTextBlock(context, startBlock)) {\n            if (\n              endChildKey &&\n              child._key === endChildKey &&\n              isSpan(context, child)\n            ) {\n              startBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n            } else {\n              startBlock.children.push(child)\n            }\n\n            if (\n              block._key === endBlockKey &&\n              endChildKey &&\n              child._key === endChildKey\n            ) {\n              break\n            }\n          }\n        }\n\n        if (startBlockKey === endBlockKey) {\n          break\n        }\n\n        continue\n      }\n\n      startBlock = block\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n    }\n\n    if (block._key === endBlockKey) {\n      if (!isTextBlock(context, block)) {\n        endBlock = block\n        break\n      }\n\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: [],\n        }\n\n        for (const child of block.children) {\n          if (endBlock && isTextBlock(context, endBlock)) {\n            if (child._key === endChildKey && isSpan(context, child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n\n              break\n            }\n\n            endBlock.children.push(child)\n\n            if (endChildKey && child._key === endChildKey) {\n              break\n            }\n          }\n        }\n\n        break\n      }\n\n      endBlock = block\n\n      break\n    }\n\n    if (startBlock) {\n      middleBlocks.push(block)\n    }\n  }\n\n  return [\n    ...(startBlock ? [startBlock] : []),\n    ...middleBlocks,\n    ...(endBlock ? [endBlock] : []),\n  ]\n}\n"],"names":["isTypedObject","object","isRecord","_type","value","parseBlocks","context","blocks","options","Array","isArray","flatMap","block","parsedBlock","parseBlock","parseTextBlock","parseBlockObject","blockObject","schemaType","schema","blockObjects","find","name","parseObject","keyGenerator","isListBlock","isTextBlock","level","undefined","listItem","refreshKeys","_key","unparsedMarkDefs","markDefs","markDefKeyMap","Map","markDef","annotations","parsedAnnotation","set","children","map","child","parseSpan","span","parseInlineObject","inlineObject","filter","length","text","marks","style","styles","defaultStyle","at","console","error","lists","list","isSpan","mark","markDefKey","get","decorators","some","decorator","inlineObjects","parseAnnotation","annotation","values","fields","reduce","fieldValues","field","fieldValue","isKeyedSegment","segment","blockOffsetToSpanSelectionPoint","blockOffset","direction","offsetLeft","offset","selectionPoint","skippedInlineObject","path","spanSelectionPointToBlockOffset","blockKey","spanKey","getBlockEndPoint","node","lastChild","getBlockStartPoint","getTextBlockText","join","isEmptyTextBlock","onlyText","every","blockText","isEqualSelectionPoints","a","b","JSON","stringify","reverseSelection","selection","backward","anchor","focus","sliceBlocks","slice","startBlock","middleBlocks","endBlock","startPoint","endPoint","startBlockKey","endBlockKey","startChildKey","endChildKey","push"],"mappings":"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"}