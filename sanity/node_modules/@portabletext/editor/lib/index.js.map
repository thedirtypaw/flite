{"version":3,"file":"index.js","sources":["../src/editor-event-listener.tsx","../src/internal-utils/compound-client-rect.ts","../src/internal-utils/drag-selection.ts","../src/internal-utils/event-position.ts","../src/internal-utils/selection.ts","../src/internal-utils/selection-elements.ts","../src/editor/components/Leaf.tsx","../src/editor/components/drop-indicator.tsx","../src/editor/components/render-default-object.tsx","../src/behaviors/behavior.core.block-element.ts","../src/editor/components/use-core-block-element-behaviors.ts","../src/editor/components/render-block-object.tsx","../src/editor/components/render-inline-object.tsx","../src/editor/components/render-text-block.tsx","../src/editor/components/render-element.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/range-decorations-machine.ts","../src/editor/Editable.tsx"],"sourcesContent":["import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/editor-machine'\nimport {useEditor} from './editor/editor-provider'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n","export function getCompoundClientRect(nodes: Array<Node>): DOMRect {\n  if (nodes.length === 0) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  const elements = nodes.filter((node) => node instanceof Element)\n\n  const firstRect = elements.at(0)?.getBoundingClientRect()\n\n  if (!firstRect) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  let left = firstRect.left\n  let top = firstRect.top\n  let right = firstRect.right\n  let bottom = firstRect.bottom\n\n  for (let i = 1; i < elements.length; i++) {\n    const rect = elements[i].getBoundingClientRect()\n    left = Math.min(left, rect.left)\n    top = Math.min(top, rect.top)\n    right = Math.max(right, rect.right)\n    bottom = Math.max(bottom, rect.bottom)\n  }\n\n  return new DOMRect(left, top, right - left, bottom - top)\n}\n","import type {EditorSnapshot} from '..'\nimport * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport type {EventPosition} from './event-position'\n\n/**\n * Given the current editor `snapshot` and an `eventSelection` representing\n * where the drag event origins from, this function calculates the selection\n * in the editor that should be dragged.\n */\nexport function getDragSelection({\n  eventSelection,\n  snapshot,\n}: {\n  eventSelection: EventPosition['selection']\n  snapshot: EditorSnapshot\n}) {\n  let dragSelection = eventSelection\n\n  const draggedInlineObject = selectors.getFocusInlineObject({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggedInlineObject) {\n    return dragSelection\n  }\n\n  const draggingCollapsedSelection = selectors.isSelectionCollapsed({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedTextBlock = selectors.getFocusTextBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedSpan = selectors.getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggingCollapsedSelection && draggedTextBlock && draggedSpan) {\n    // Looks like we are dragging an empty span\n    // Let's drag the entire block instead\n    dragSelection = {\n      anchor: utils.getBlockStartPoint({\n        context: snapshot.context,\n        block: draggedTextBlock,\n      }),\n      focus: utils.getBlockEndPoint({\n        context: snapshot.context,\n        block: draggedTextBlock,\n      }),\n    }\n  }\n\n  const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n\n  if (\n    snapshot.context.selection &&\n    selectors.isSelectionExpanded(snapshot) &&\n    selectedBlocks.length > 1\n  ) {\n    const selectionStartBlock = selectors.getSelectionStartBlock(snapshot)\n    const selectionEndBlock = selectors.getSelectionEndBlock(snapshot)\n\n    if (!selectionStartBlock || !selectionEndBlock) {\n      return dragSelection\n    }\n\n    const selectionStartPoint = utils.getBlockStartPoint({\n      context: snapshot.context,\n      block: selectionStartBlock,\n    })\n    const selectionEndPoint = utils.getBlockEndPoint({\n      context: snapshot.context,\n      block: selectionEndBlock,\n    })\n\n    const eventSelectionInsideBlocks = selectors.isOverlappingSelection(\n      eventSelection,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {anchor: selectionStartPoint, focus: selectionEndPoint},\n      },\n    })\n\n    if (eventSelectionInsideBlocks) {\n      dragSelection = {\n        anchor: selectionStartPoint,\n        focus: selectionEndPoint,\n      }\n    }\n  }\n\n  return dragSelection\n}\n","import {Editor, type BaseRange, type Node} from 'slate'\nimport {DOMEditor, isDOMNode} from 'slate-dom'\nimport type {EditorSchema, EditorSelection} from '..'\nimport type {EditorActor} from '../editor/editor-machine'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport * as utils from '../utils'\nimport {\n  getFirstBlock,\n  getLastBlock,\n  getNodeBlock,\n  slateRangeToSelection,\n} from './slate-utils'\n\nexport type EventPosition = {\n  block: 'start' | 'end'\n  /**\n   * Did the event origin from the editor DOM node itself or from a child node?\n   */\n  isEditor: boolean\n  selection: NonNullable<EditorSelection>\n}\nexport type EventPositionBlock = EventPosition['block']\n\nexport function getEventPosition({\n  editorActor,\n  slateEditor,\n  event,\n}: {\n  editorActor: EditorActor\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPosition | undefined {\n  if (editorActor.getSnapshot().matches({setup: 'setting up'})) {\n    return undefined\n  }\n\n  const node = getEventNode({slateEditor, event})\n\n  if (!node) {\n    return undefined\n  }\n\n  const block = getNodeBlock({\n    editor: slateEditor,\n    schema: editorActor.getSnapshot().context.schema,\n    node,\n  })\n\n  const positionBlock = getEventPositionBlock({node, slateEditor, event})\n  const selection = getEventSelection({\n    schema: editorActor.getSnapshot().context.schema,\n    slateEditor,\n    event,\n  })\n\n  if (block && positionBlock && !selection && !Editor.isEditor(node)) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{_key: block._key}],\n          },\n        }),\n        focus: utils.getBlockEndPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{_key: block._key}],\n          },\n        }),\n      },\n    }\n  }\n\n  if (!positionBlock || !selection) {\n    return undefined\n  }\n\n  const focusBlockPath = selection.focus.path.at(0)\n  const focusBlockKey = utils.isKeyedSegment(focusBlockPath)\n    ? focusBlockPath._key\n    : undefined\n\n  if (!focusBlockKey) {\n    return undefined\n  }\n\n  if (\n    utils.isSelectionCollapsed(selection) &&\n    block &&\n    focusBlockKey !== block._key\n  ) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{_key: block._key}],\n          },\n        }),\n        focus: utils.getBlockEndPoint({\n          context: editorActor.getSnapshot().context,\n          block: {\n            node: block,\n            path: [{_key: block._key}],\n          },\n        }),\n      },\n    }\n  }\n\n  return {\n    block: positionBlock,\n    isEditor: Editor.isEditor(node),\n    selection,\n  }\n}\n\nexport function getEventNode({\n  slateEditor,\n  event,\n}: {\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}) {\n  if (!DOMEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = DOMEditor.toSlateNode(slateEditor, event.target)\n\n  return node\n}\n\nfunction getEventPositionBlock({\n  node,\n  slateEditor,\n  event,\n}: {\n  node: Node\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPositionBlock | undefined {\n  const [firstBlock] = getFirstBlock({editor: slateEditor})\n\n  if (!firstBlock) {\n    return undefined\n  }\n\n  const firstBlockElement = DOMEditor.toDOMNode(slateEditor, firstBlock)\n  const firstBlockRect = firstBlockElement.getBoundingClientRect()\n\n  if (event.pageY < firstBlockRect.top) {\n    return 'start'\n  }\n\n  const [lastBlock] = getLastBlock({editor: slateEditor})\n\n  if (!lastBlock) {\n    return undefined\n  }\n\n  const lastBlockElement = DOMEditor.toDOMNode(slateEditor, lastBlock)\n  const lastBlockRef = lastBlockElement.getBoundingClientRect()\n\n  if (event.pageY > lastBlockRef.bottom) {\n    return 'end'\n  }\n\n  const element = DOMEditor.toDOMNode(slateEditor, node)\n  const elementRect = element.getBoundingClientRect()\n  const top = elementRect.top\n  const height = elementRect.height\n  const location = Math.abs(top - event.pageY)\n\n  return location < height / 2 ? 'start' : 'end'\n}\n\nexport function getEventSelection({\n  schema,\n  slateEditor,\n  event,\n}: {\n  schema: EditorSchema\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EditorSelection {\n  const range = getSlateRangeFromEvent(slateEditor, event)\n\n  const selection = range\n    ? slateRangeToSelection({\n        schema,\n        editor: slateEditor,\n        range,\n      })\n    : null\n\n  return selection\n}\n\nfunction getSlateRangeFromEvent(\n  editor: PortableTextSlateEditor,\n  event: DragEvent | MouseEvent,\n) {\n  if (!event.target) {\n    return undefined\n  }\n\n  if (!isDOMNode(event.target)) {\n    return undefined\n  }\n\n  const window = DOMEditor.getWindow(editor)\n\n  let domRange: Range | undefined\n\n  if (window.document.caretPositionFromPoint !== undefined) {\n    const position = window.document.caretPositionFromPoint(\n      event.clientX,\n      event.clientY,\n    )\n\n    if (position) {\n      try {\n        domRange = window.document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      } catch {}\n    }\n  } else if (window.document.caretRangeFromPoint !== undefined) {\n    // Use WebKit-proprietary fallback method\n    domRange =\n      window.document.caretRangeFromPoint(event.clientX, event.clientY) ??\n      undefined\n  } else {\n    console.warn(\n      'Neither caretPositionFromPoint nor caretRangeFromPoint is supported',\n    )\n    return undefined\n  }\n\n  if (!domRange) {\n    return undefined\n  }\n\n  let range: BaseRange | undefined\n\n  try {\n    range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      // It can still throw even with this option set to true\n      suppressThrow: false,\n    })\n  } catch {}\n\n  return range\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import {Editor} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport type {EditorSnapshot} from '..'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {toSlateRange} from './ranges'\n\nexport type SelectionDomNodes = {\n  blockNodes: Array<Node>\n  childNodes: Array<Node>\n}\n\nexport function getSelectionDomNodes({\n  slateEditor,\n  snapshot,\n}: {\n  slateEditor: PortableTextSlateEditor\n  snapshot: EditorSnapshot\n}): SelectionDomNodes {\n  if (!snapshot.context.selection) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const range = toSlateRange(snapshot.context.selection, slateEditor)\n\n  if (!range) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const blockEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'highest',\n      match: (n) => !Editor.isEditor(n),\n    }),\n  )\n\n  const childEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'lowest',\n      match: (n) =>\n        (!Editor.isEditor(n) && slateEditor.isTextSpan(n)) ||\n        !slateEditor.isBlock(n),\n    }),\n  )\n\n  return {\n    blockNodes: blockEntries.map(([blockNode]) =>\n      DOMEditor.toDOMNode(slateEditor, blockNode),\n    ),\n    childNodes: childEntries.map(([childNode]) =>\n      DOMEditor.toDOMNode(slateEditor, childNode),\n    ),\n  }\n}\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blurred', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focused', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = <span ref={spanRef}>{returnedChildren}</span>\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span\n        key={leaf._key}\n        {...attributes}\n        ref={spanRef}\n        data-child-key={leaf._key}\n        data-child-name={leaf._type}\n        data-child-type=\"span\"\n      >\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","export function DropIndicator() {\n  return (\n    <div\n      contentEditable={false}\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    >\n      <span />\n    </div>\n  )\n}\n","import type {PortableTextChild, PortableTextObject} from '@sanity/types'\n\nexport function RenderDefaultBlockObject(props: {\n  blockObject: PortableTextObject\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.blockObject._type}: {props.blockObject._key}]\n    </div>\n  )\n}\n\nexport function RenderDefaultInlineObject(props: {\n  inlineObject: PortableTextObject | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.inlineObject._type}: {props.inlineObject._key}]\n    </span>\n  )\n}\n","import type {EventPositionBlock} from '../internal-utils/event-position'\nimport {corePriority} from '../priority/priority.core'\nimport {createEditorPriority} from '../priority/priority.types'\nimport * as selectors from '../selectors'\nimport {forward} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\nexport function createCoreBlockElementBehaviorsConfig({\n  key,\n  onSetDragPositionBlock,\n}: {\n  key: string\n  onSetDragPositionBlock: (\n    eventPositionBlock: EventPositionBlock | undefined,\n  ) => void\n}) {\n  return [\n    {\n      behavior: defineBehavior({\n        on: 'drag.dragover',\n        guard: ({snapshot, event}) => {\n          const dropFocusBlock = selectors.getFocusBlock({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: event.position.selection,\n            },\n          })\n\n          if (!dropFocusBlock || dropFocusBlock.node._key !== key) {\n            return false\n          }\n\n          const dragOrigin = snapshot.beta.internalDrag?.origin\n\n          if (!dragOrigin) {\n            return false\n          }\n\n          const draggedBlocks = selectors.getSelectedBlocks({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: dragOrigin.selection,\n            },\n          })\n\n          if (\n            draggedBlocks.some((draggedBlock) => draggedBlock.node._key === key)\n          ) {\n            return false\n          }\n\n          const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n            ...snapshot,\n            context: {\n              ...snapshot.context,\n              selection: dragOrigin.selection,\n            },\n          })\n\n          return draggingEntireBlocks\n        },\n        actions: [\n          ({event}) => [\n            {\n              type: 'effect',\n              effect: () => {\n                onSetDragPositionBlock(event.position.block)\n              },\n            },\n          ],\n        ],\n      }),\n      priority: createEditorPriority({\n        reference: {\n          priority: corePriority,\n          importance: 'lower',\n        },\n      }),\n    },\n    {\n      behavior: defineBehavior({\n        on: 'drag.*',\n        guard: ({event}) => {\n          return event.type !== 'drag.dragover'\n        },\n        actions: [\n          ({event}) => [\n            {\n              type: 'effect',\n              effect: () => {\n                onSetDragPositionBlock(undefined)\n              },\n            },\n            forward(event),\n          ],\n        ],\n      }),\n      priority: createEditorPriority({\n        reference: {\n          priority: corePriority,\n          importance: 'lower',\n        },\n      }),\n    },\n  ]\n}\n","import {useContext, useEffect} from 'react'\nimport {createCoreBlockElementBehaviorsConfig} from '../../behaviors/behavior.core.block-element'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport {EditorActorContext} from '../editor-actor-context'\n\nexport function useCoreBlockElementBehaviors({\n  key,\n  onSetDragPositionBlock,\n}: {\n  key: string\n  onSetDragPositionBlock: (\n    eventPositionBlock: EventPositionBlock | undefined,\n  ) => void\n}) {\n  const editorActor = useContext(EditorActorContext)\n\n  useEffect(() => {\n    const behaviorConfigs = createCoreBlockElementBehaviorsConfig({\n      key,\n      onSetDragPositionBlock,\n    })\n\n    for (const behaviorConfig of behaviorConfigs) {\n      editorActor.send({\n        type: 'add behavior',\n        behaviorConfig,\n      })\n    }\n\n    return () => {\n      for (const behaviorConfig of behaviorConfigs) {\n        editorActor.send({\n          type: 'remove behavior',\n          behaviorConfig,\n        })\n      }\n    }\n  }, [editorActor, key, onSetDragPositionBlock])\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {useContext, useRef, useState, type ReactElement} from 'react'\nimport {Range, type Element as SlateElement} from 'slate'\nimport {useSelected, useSlateStatic, type RenderElementProps} from 'slate-react'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport type {RenderBlockFunction} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DropIndicator} from './drop-indicator'\nimport {RenderDefaultBlockObject} from './render-default-object'\nimport {useCoreBlockElementBehaviors} from './use-core-block-element-behaviors'\n\nexport function RenderBlockObject(props: {\n  attributes: RenderElementProps['attributes']\n  blockObject: PortableTextObject\n  children: ReactElement\n  element: SlateElement\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n}) {\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n  const blockObjectRef = useRef<HTMLDivElement>(null)\n\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n\n  const editorActor = useContext(EditorActorContext)\n\n  useCoreBlockElementBehaviors({\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock,\n  })\n\n  const legacySchemaType = useSelector(editorActor, (s) =>\n    s.context\n      .getLegacySchema()\n      .blockObjects.find(\n        (blockObject) => blockObject.name === props.element._type,\n      ),\n  )\n\n  if (!legacySchemaType) {\n    console.error(\n      `Block object type ${props.element._type} not found in Schema`,\n    )\n  }\n\n  const focused =\n    selected &&\n    slateEditor.selection !== null &&\n    Range.isCollapsed(slateEditor.selection)\n\n  return (\n    <div\n      key={props.element._key}\n      {...props.attributes}\n      className=\"pt-block pt-object-block\"\n      data-block-key={props.element._key}\n      data-block-name={props.element._type}\n      data-block-type=\"object\"\n    >\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      {props.children}\n      <div\n        ref={blockObjectRef}\n        contentEditable={false}\n        draggable={!props.readOnly}\n      >\n        {props.renderBlock && legacySchemaType ? (\n          props.renderBlock({\n            children: (\n              <RenderDefaultBlockObject blockObject={props.blockObject} />\n            ),\n            editorElementRef: blockObjectRef,\n            focused,\n            path: [{_key: props.element._key}],\n            schemaType: legacySchemaType,\n            selected,\n            type: legacySchemaType,\n            value: props.blockObject,\n          })\n        ) : (\n          <RenderDefaultBlockObject blockObject={props.blockObject} />\n        )}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {useContext, useRef, type ReactElement} from 'react'\nimport {Range, type Element as SlateElement} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport {useSelected, useSlateStatic, type RenderElementProps} from 'slate-react'\nimport {getPointBlock} from '../../internal-utils/slate-utils'\nimport type {RenderChildFunction} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {RenderDefaultInlineObject} from './render-default-object'\n\nexport function RenderInlineObject(props: {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement\n  element: SlateElement\n  inlineObject: PortableTextObject\n  readOnly: boolean\n  renderChild?: RenderChildFunction\n}) {\n  const inlineObjectRef = useRef<HTMLElement>(null)\n\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n\n  const editorActor = useContext(EditorActorContext)\n  const legacySchemaType = useSelector(editorActor, (s) =>\n    s.context\n      .getLegacySchema()\n      .inlineObjects.find(\n        (inlineObject) => inlineObject.name === props.element._type,\n      ),\n  )\n\n  if (!legacySchemaType) {\n    console.error(\n      `Inline object type ${props.element._type} not found in Schema`,\n    )\n  }\n\n  const focused =\n    selected &&\n    slateEditor.selection !== null &&\n    Range.isCollapsed(slateEditor.selection)\n  const path = DOMEditor.findPath(slateEditor, props.element)\n  const [block] = getPointBlock({\n    editor: slateEditor,\n    point: {\n      path,\n      offset: 0,\n    },\n  })\n\n  if (!block) {\n    console.error(\n      `Unable to find parent block of inline object ${props.element._key}`,\n    )\n  }\n\n  return (\n    <span {...props.attributes}>\n      {props.children}\n      <span\n        draggable={!props.readOnly}\n        className=\"pt-inline-object\"\n        data-testid=\"pt-inline-object\"\n        ref={inlineObjectRef}\n        key={props.element._key}\n        style={{display: 'inline-block'}}\n        data-child-key={props.inlineObject._key}\n        data-child-name={props.inlineObject._type}\n        data-child-type=\"object\"\n      >\n        {props.renderChild && block && legacySchemaType ? (\n          props.renderChild({\n            annotations: [],\n            children: (\n              <RenderDefaultInlineObject inlineObject={props.inlineObject} />\n            ),\n            editorElementRef: inlineObjectRef,\n            selected,\n            focused,\n            path: [{_key: block._key}, 'children', {_key: props.element._key}],\n            schemaType: legacySchemaType,\n            value: props.inlineObject,\n            type: legacySchemaType,\n          })\n        ) : (\n          <RenderDefaultInlineObject inlineObject={props.inlineObject} />\n        )}\n      </span>\n    </span>\n  )\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {useSelector} from '@xstate/react'\nimport {useContext, useRef, useState, type ReactElement} from 'react'\nimport {Range, type Element as SlateElement} from 'slate'\nimport {useSelected, useSlateStatic, type RenderElementProps} from 'slate-react'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport type {\n  RenderBlockFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DropIndicator} from './drop-indicator'\nimport {useCoreBlockElementBehaviors} from './use-core-block-element-behaviors'\n\nexport function RenderTextBlock(props: {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement\n  element: SlateElement\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n  textBlock: PortableTextTextBlock\n}) {\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n  const blockRef = useRef<HTMLDivElement>(null)\n\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n\n  const editorActor = useContext(EditorActorContext)\n\n  useCoreBlockElementBehaviors({\n    key: props.element._key,\n    onSetDragPositionBlock: setDragPositionBlock,\n  })\n\n  const legacySchema = useSelector(editorActor, (s) =>\n    s.context.getLegacySchema(),\n  )\n\n  const focused =\n    selected &&\n    slateEditor.selection !== null &&\n    Range.isCollapsed(slateEditor.selection)\n\n  let children = props.children\n\n  const legacyBlockSchemaType = legacySchema.block\n\n  if (props.renderStyle && props.textBlock.style) {\n    const legacyStyleSchemaType =\n      props.textBlock.style !== undefined\n        ? legacySchema.styles.find(\n            (style) => style.value === props.textBlock.style,\n          )\n        : undefined\n\n    if (legacyStyleSchemaType) {\n      children = props.renderStyle({\n        block: props.textBlock,\n        children,\n        editorElementRef: blockRef,\n        focused,\n        path: [{_key: props.textBlock._key}],\n        schemaType: legacyStyleSchemaType,\n        selected,\n        value: props.textBlock.style,\n      })\n    } else {\n      console.error(\n        `Unable to find Schema type for text block style ${props.textBlock.style}`,\n      )\n    }\n  }\n\n  if (props.renderListItem && props.textBlock.listItem) {\n    const legacyListItemSchemaType = legacySchema.lists.find(\n      (list) => list.value === props.textBlock.listItem,\n    )\n\n    if (legacyListItemSchemaType) {\n      children = props.renderListItem({\n        block: props.textBlock,\n        children,\n        editorElementRef: blockRef,\n        focused,\n        level: props.textBlock.level ?? 1,\n        path: [{_key: props.textBlock._key}],\n        selected,\n        value: props.textBlock.listItem,\n        schemaType: legacyListItemSchemaType,\n      })\n    } else {\n      console.error(\n        `Unable to find Schema type for text block list item ${props.textBlock.listItem}`,\n      )\n    }\n  }\n\n  return (\n    <div\n      key={props.element._key}\n      {...props.attributes}\n      className={[\n        'pt-block',\n        'pt-text-block',\n        ...(props.textBlock.style\n          ? [`pt-text-block-style-${props.textBlock.style}`]\n          : []),\n        ...(props.textBlock.listItem\n          ? [\n              'pt-list-item',\n              `pt-list-item-${props.textBlock.listItem}`,\n              `pt-list-item-level-${props.textBlock.level ?? 1}`,\n            ]\n          : []),\n      ].join(' ')}\n      spellCheck={props.spellCheck}\n      data-block-key={props.textBlock._key}\n      data-block-name={props.textBlock._type}\n      data-block-type=\"text\"\n    >\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      <div ref={blockRef}>\n        {props.renderBlock\n          ? props.renderBlock({\n              children,\n              editorElementRef: blockRef,\n              focused,\n              level: props.textBlock.level,\n              listItem: props.textBlock.listItem,\n              path: [{_key: props.textBlock._key}],\n              selected,\n              schemaType: legacyBlockSchemaType,\n              style: props.textBlock.style,\n              type: legacyBlockSchemaType,\n              value: props.textBlock,\n            })\n          : props.children}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n","import {useSelector} from '@xstate/react'\nimport {useContext, type ReactElement} from 'react'\nimport type {Element as SlateElement} from 'slate'\nimport type {RenderElementProps} from 'slate-react'\nimport {\n  parseBlockObject,\n  parseInlineObject,\n  parseTextBlock,\n} from '../../internal-utils/parse-blocks'\nimport type {\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {RenderBlockObject} from './render-block-object'\nimport {RenderInlineObject} from './render-inline-object'\nimport {RenderTextBlock} from './render-text-block'\n\nexport function RenderElement(props: {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement\n  element: SlateElement\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}) {\n  const editorActor = useContext(EditorActorContext)\n  const schema = useSelector(editorActor, (s) => s.context.schema)\n  const isInline =\n    '__inline' in props.element && props.element.__inline === true\n\n  if (isInline) {\n    const inlineObject = parseInlineObject({\n      context: {\n        keyGenerator: () => '',\n        schema,\n      },\n      options: {refreshKeys: false},\n      inlineObject: {\n        _key: props.element._key,\n        _type: props.element._type,\n        ...('value' in props.element && typeof props.element.value === 'object'\n          ? props.element.value\n          : {}),\n      },\n    })\n\n    if (!inlineObject) {\n      console.error(\n        `Unable to find Inline Object \"${props.element._type}\" in Schema`,\n      )\n    }\n\n    return (\n      <RenderInlineObject\n        attributes={props.attributes}\n        element={props.element}\n        inlineObject={\n          inlineObject ?? {\n            _key: props.element._key,\n            _type: props.element._type,\n          }\n        }\n        readOnly={props.readOnly}\n        renderChild={props.renderChild}\n      >\n        {props.children}\n      </RenderInlineObject>\n    )\n  }\n\n  const textBlock = parseTextBlock({\n    context: {\n      keyGenerator: () => '',\n      schema,\n    },\n    options: {refreshKeys: false},\n    block: props.element,\n  })\n\n  if (textBlock) {\n    return (\n      <RenderTextBlock\n        attributes={props.attributes}\n        element={props.element}\n        readOnly={props.readOnly}\n        renderBlock={props.renderBlock}\n        renderListItem={props.renderListItem}\n        renderStyle={props.renderStyle}\n        spellCheck={props.spellCheck}\n        textBlock={textBlock}\n      >\n        {props.children}\n      </RenderTextBlock>\n    )\n  }\n\n  const blockObject = parseBlockObject({\n    context: {\n      keyGenerator: () => '',\n      schema,\n    },\n    options: {refreshKeys: false},\n    blockObject: {\n      _key: props.element._key,\n      _type: props.element._type,\n      ...('value' in props.element && typeof props.element.value === 'object'\n        ? props.element.value\n        : {}),\n    },\n  })\n\n  if (!blockObject) {\n    console.error(\n      `Unable to find Block Object \"${props.element._type}\" in Schema`,\n    )\n  }\n\n  return (\n    <RenderBlockObject\n      attributes={props.attributes}\n      blockObject={\n        blockObject ?? {\n          _key: props.element._key,\n          _type: props.element._type,\n        }\n      }\n      element={props.element}\n      readOnly={props.readOnly}\n      renderBlock={props.renderBlock}\n    >\n      {props.children}\n    </RenderBlockObject>\n  )\n}\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import {isEqual} from 'lodash'\nimport {\n  Element,\n  Path,\n  Range,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n} from 'slate'\nimport {\n  and,\n  assign,\n  fromCallback,\n  setup,\n  type ActorRefFrom,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport {moveRangeByOperation, toSlateRange} from '../internal-utils/ranges'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {isEqualToEmptyEditor} from '../internal-utils/values'\nimport type {PortableTextSlateEditor, RangeDecoration} from '../types/editor'\nimport type {EditorSchema} from './editor-schema'\n\nconst slateOperationCallback: CallbackLogicFunction<\n  AnyEventObject,\n  {type: 'slate operation'; operation: Operation},\n  {slateEditor: PortableTextSlateEditor}\n> = ({input, sendBack}) => {\n  const originalApply = input.slateEditor.apply\n\n  input.slateEditor.apply = (op) => {\n    if (op.type !== 'set_selection') {\n      sendBack({type: 'slate operation', operation: op})\n    }\n\n    originalApply(op)\n  }\n\n  return () => {\n    input.slateEditor.apply = originalApply\n  }\n}\n\ntype DecoratedRange = BaseRange & {rangeDecoration: RangeDecoration}\n\nexport const rangeDecorationsMachine = setup({\n  types: {\n    context: {} as {\n      decoratedRanges: Array<DecoratedRange>\n      pendingRangeDecorations: Array<RangeDecoration>\n      skipSetup: boolean\n      readOnly: boolean\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n      updateCount: number\n    },\n    input: {} as {\n      rangeDecorations: Array<RangeDecoration>\n      readOnly: boolean\n      schema: EditorSchema\n      skipSetup: boolean\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as\n      | {\n          type: 'ready'\n        }\n      | {\n          type: 'range decorations updated'\n          rangeDecorations: Array<RangeDecoration>\n        }\n      | {\n          type: 'slate operation'\n          operation: Operation\n        }\n      | {\n          type: 'update read only'\n          readOnly: boolean\n        },\n  },\n  actions: {\n    'update pending range decorations': assign({\n      pendingRangeDecorations: ({context, event}) => {\n        if (event.type !== 'range decorations updated') {\n          return context.pendingRangeDecorations\n        }\n\n        return event.rangeDecorations\n      },\n    }),\n    'set up initial range decorations': assign({\n      decoratedRanges: ({context}) => {\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of context.pendingRangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'update range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        if (event.type !== 'range decorations updated') {\n          return context.decoratedRanges\n        }\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of event.rangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'move range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        if (event.type !== 'slate operation') {\n          return context.decoratedRanges\n        }\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const decoratedRange of context.decoratedRanges) {\n          const slateRange = toSlateRange(\n            decoratedRange.rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          let newRange: BaseRange | null | undefined\n\n          newRange = moveRangeByOperation(slateRange, event.operation)\n          if (\n            (newRange && newRange !== slateRange) ||\n            (newRange === null && slateRange)\n          ) {\n            const newRangeSelection = newRange\n              ? slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                })\n              : null\n\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: newRangeSelection,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n          }\n\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            rangeDecorationState.push({\n              ...(newRange || slateRange),\n              rangeDecoration: {\n                ...decoratedRange.rangeDecoration,\n                selection: slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                }),\n              },\n            })\n          }\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'assign readOnly': assign({\n      readOnly: ({context, event}) => {\n        if (event.type !== 'update read only') {\n          return context.readOnly\n        }\n\n        return event.readOnly\n      },\n    }),\n    'increment update count': assign({\n      updateCount: ({context}) => {\n        return context.updateCount + 1\n      },\n    }),\n  },\n  actors: {\n    'slate operation listener': fromCallback(slateOperationCallback),\n  },\n  guards: {\n    'has pending range decorations': ({context}) =>\n      context.pendingRangeDecorations.length > 0,\n    'has range decorations': ({context}) => context.decoratedRanges.length > 0,\n    'has different decorations': ({context, event}) => {\n      if (event.type !== 'range decorations updated') {\n        return false\n      }\n\n      const existingRangeDecorations = context.decoratedRanges.map(\n        (decoratedRange) => ({\n          anchor: decoratedRange.rangeDecoration.selection?.anchor,\n          focus: decoratedRange.rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const newRangeDecorations = event.rangeDecorations.map(\n        (rangeDecoration) => ({\n          anchor: rangeDecoration.selection?.anchor,\n          focus: rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const different = !isEqual(existingRangeDecorations, newRangeDecorations)\n\n      return different\n    },\n    'not read only': ({context}) => !context.readOnly,\n    'should skip setup': ({context}) => context.skipSetup,\n  },\n}).createMachine({\n  id: 'range decorations',\n  context: ({input}) => ({\n    readOnly: input.readOnly,\n    pendingRangeDecorations: input.rangeDecorations,\n    decoratedRanges: [],\n    skipSetup: input.skipSetup,\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n    updateCount: 0,\n  }),\n  invoke: {\n    src: 'slate operation listener',\n    input: ({context}) => ({slateEditor: context.slateEditor}),\n  },\n  on: {\n    'update read only': {\n      actions: ['assign readOnly'],\n    },\n  },\n  initial: 'setting up',\n  states: {\n    'setting up': {\n      always: [\n        {\n          guard: and(['should skip setup', 'has pending range decorations']),\n          target: 'ready',\n          actions: [\n            'set up initial range decorations',\n            'increment update count',\n          ],\n        },\n        {\n          guard: 'should skip setup',\n          target: 'ready',\n        },\n      ],\n      on: {\n        'range decorations updated': {\n          actions: ['update pending range decorations'],\n        },\n        'ready': [\n          {\n            target: 'ready',\n            guard: 'has pending range decorations',\n            actions: [\n              'set up initial range decorations',\n              'increment update count',\n            ],\n          },\n          {\n            target: 'ready',\n          },\n        ],\n      },\n    },\n    'ready': {\n      initial: 'idle',\n      on: {\n        'range decorations updated': {\n          target: '.idle',\n          guard: 'has different decorations',\n          actions: ['update range decorations', 'increment update count'],\n        },\n      },\n      states: {\n        'idle': {\n          on: {\n            'slate operation': {\n              target: 'moving range decorations',\n              guard: and(['has range decorations', 'not read only']),\n            },\n          },\n        },\n        'moving range decorations': {\n          entry: ['move range decorations'],\n          always: {\n            target: 'idle',\n          },\n        },\n      },\n    },\n  },\n})\n\nexport function createDecorate(\n  rangeDecorationActor: ActorRefFrom<typeof rangeDecorationsMachine>,\n) {\n  return function decorate([node, path]: NodeEntry): Array<BaseRange> {\n    if (\n      isEqualToEmptyEditor(\n        rangeDecorationActor.getSnapshot().context.slateEditor.children,\n        rangeDecorationActor.getSnapshot().context.schema,\n      )\n    ) {\n      return [\n        {\n          anchor: {\n            path: [0, 0],\n            offset: 0,\n          },\n          focus: {\n            path: [0, 0],\n            offset: 0,\n          },\n          placeholder: true,\n        } as BaseRange,\n      ]\n    }\n\n    // Editor node has a path length of 0 (should never be decorated)\n    if (path.length === 0) {\n      return []\n    }\n\n    if (!Element.isElement(node) || node.children.length === 0) {\n      return []\n    }\n\n    const blockIndex = path.at(0)\n\n    if (blockIndex === undefined) {\n      return []\n    }\n\n    return rangeDecorationActor\n      .getSnapshot()\n      .context.decoratedRanges.filter((decoratedRange) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (Range.isCollapsed(decoratedRange)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          return node.children.some(\n            (_, childIndex) =>\n              Path.equals(decoratedRange.anchor.path, [\n                blockIndex,\n                childIndex,\n              ]) &&\n              Path.equals(decoratedRange.focus.path, [blockIndex, childIndex]),\n          )\n        }\n\n        return (\n          Range.intersection(decoratedRange, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || Range.includes(decoratedRange, path)\n        )\n      })\n  }\n}\n","import {useActorRef, useSelector} from '@xstate/react'\nimport {noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {Editor, Transforms, type Text} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {getCompoundClientRect} from '../internal-utils/compound-client-rect'\nimport {debugWithName} from '../internal-utils/debug'\nimport {getDragSelection} from '../internal-utils/drag-selection'\nimport {getEventPosition} from '../internal-utils/event-position'\nimport {parseBlocks} from '../internal-utils/parse-blocks'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {getSelectionDomNodes} from '../internal-utils/selection-elements'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport * as selectors from '../selectors'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport {isSelectionCollapsed} from '../utils'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {Leaf} from './components/Leaf'\nimport {RenderElement} from './components/render-element'\nimport {EditorActorContext} from './editor-actor-context'\nimport {getEditorSnapshot} from './editor-selector'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {\n  createDecorate,\n  rangeDecorationsMachine,\n} from './range-decorations-machine'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const slateEditor = useSlate()\n\n  const rangeDecorationsActor = useActorRef(rangeDecorationsMachine, {\n    input: {\n      rangeDecorations: rangeDecorations ?? [],\n      readOnly,\n      schema: editorActor.getSnapshot().context.schema,\n      slateEditor,\n      skipSetup: !editorActor.getSnapshot().matches({setup: 'setting up'}),\n    },\n  })\n  useSelector(rangeDecorationsActor, (s) => s.context.updateCount)\n  const decorate = useMemo(\n    () => createDecorate(rangeDecorationsActor),\n    [rangeDecorationsActor],\n  )\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'update read only',\n      readOnly,\n    })\n  }, [rangeDecorationsActor, readOnly])\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'range decorations updated',\n      rangeDecorations: rangeDecorations ?? [],\n    })\n  }, [rangeDecorationsActor, rangeDecorations])\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <RenderElement\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={portableTextEditor.schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      portableTextEditor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(\n          slateEditor.children,\n          editorActor.getSnapshot().context.schema.block.name,\n        ),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'notify.selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [editorActor, propsSelection, slateEditor])\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      rangeDecorationsActor.send({\n        type: 'ready',\n      })\n\n      restoreSelectionFromProps()\n    })\n\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [rangeDecorationsActor, editorActor, restoreSelectionFromProps])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = slateEditor.selection\n          ? slateRangeToSelection({\n              schema: editorActor.getSnapshot().context.schema,\n              editor: slateEditor,\n              range: slateEditor.selection,\n            })\n          : undefined\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for copy event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.copy',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  const handleCut = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>) => {\n      if (onCut) {\n        const result = onCut(event)\n        // CutFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for cut event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.cut',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCut, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = fromSlateValue(\n        slateEditor.children,\n        editorActor.getSnapshot().context.schema.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )\n      const ptRange = slateEditor.selection\n        ? slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor: slateEditor,\n            range: slateEditor.selection,\n          })\n        : null\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({\n        event,\n        value,\n        path,\n        schemaTypes: portableTextEditor.schemaTypes,\n      })\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'notify.loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              const selection = editorActor.getSnapshot().context.selection\n              const position = selection ? {selection} : undefined\n\n              if (!position) {\n                console.warn('Could not find position for paste event')\n                return\n              }\n\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'clipboard.paste',\n                  originEvent: {\n                    dataTransfer: event.clipboardData,\n                  },\n                  position,\n                },\n                editor: slateEditor,\n                nativeEvent: event,\n              })\n            } else if (result.insert) {\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'insert.blocks',\n                  blocks: parseBlocks({\n                    context: {\n                      keyGenerator:\n                        editorActor.getSnapshot().context.keyGenerator,\n                      schema: editorActor.getSnapshot().context.schema,\n                    },\n                    blocks: result.insert,\n                    options: {\n                      refreshKeys: true,\n                    },\n                  }),\n                  placement: 'auto',\n                },\n                editor: slateEditor,\n              })\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.warn(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'notify.done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.preventDefault()\n        event.stopPropagation()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for paste event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.paste',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'notify.focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'notify.selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, slateEditor, portableTextEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (position) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'mouse.click',\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onClick, editorActor, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'notify.blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keydown',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keyup',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  const handleDragStart = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragStart?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for dragstart event')\n        return\n      }\n\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: slateEditor,\n      })\n      const dragSelection = getDragSelection({\n        eventSelection: position.selection,\n        snapshot,\n      })\n\n      const selectingEntireBlocks = selectors.isSelectingEntireBlocks({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection,\n        },\n      })\n\n      const dragGhost = document.createElement('div')\n\n      const draggedDomNodes = getSelectionDomNodes({\n        snapshot: {\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection,\n          },\n        },\n        slateEditor,\n      })\n\n      if (selectingEntireBlocks) {\n        // Clone the DOM Nodes so they won't be visually clipped by scroll-containers etc.\n        const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const block of clonedBlockNodes) {\n          if (block instanceof HTMLElement) {\n            block.style.position = 'relative'\n          }\n          dragGhost.appendChild(block)\n        }\n\n        // A custom drag ghost element can be configured using this data attribute\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost.replaceChildren(customGhost)\n        }\n\n        // Setting the `data-dragged` attribute so the consumer can style the element while it’s dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        if (customGhost) {\n          const customGhostRect = customGhost.getBoundingClientRect()\n          const x = event.clientX - customGhostRect.left\n          const y = event.clientY - customGhostRect.top\n          dragGhost.style.width = `${customGhostRect.width}px`\n          dragGhost.style.height = `${customGhostRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        } else {\n          const blocksDomRect = getCompoundClientRect(\n            draggedDomNodes.blockNodes,\n          )\n          const x = event.clientX - blocksDomRect.left\n          const y = event.clientY - blocksDomRect.top\n          dragGhost.style.width = `${blocksDomRect.width}px`\n          dragGhost.style.height = `${blocksDomRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        }\n      } else {\n        const clonedChildNodes = draggedDomNodes.childNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const child of clonedChildNodes) {\n          dragGhost.appendChild(child)\n        }\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        const childrenDomRect = getCompoundClientRect(\n          draggedDomNodes.childNodes,\n        )\n        const x = event.clientX - childrenDomRect.left\n        const y = event.clientY - childrenDomRect.top\n        dragGhost.style.width = `${childrenDomRect.width}px`\n        dragGhost.style.height = `${childrenDomRect.height}px`\n\n        event.dataTransfer.setDragImage(dragGhost, x, y)\n      }\n\n      // Select drag selection\n      // If the selection is expanded then we just select the end of the\n      // selection\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'select',\n          at: isSelectionCollapsed(dragSelection)\n            ? dragSelection\n            : {\n                anchor: getSelectionEndPoint(dragSelection),\n                focus: getSelectionEndPoint(dragSelection),\n                backward: false,\n              },\n        },\n        editor: slateEditor,\n      })\n\n      editorActor.send({\n        type: 'dragstart',\n        origin: {\n          selection: dragSelection,\n        },\n        ghost: dragGhost,\n      })\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragstart',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position: {\n            selection: dragSelection,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragStart, editorActor, slateEditor],\n  )\n\n  const handleDrag = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrag?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drag',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrag, editorActor, slateEditor],\n  )\n\n  const handleDragEnd = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnd?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragend',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnd, editorActor, slateEditor],\n  )\n\n  const handleDragEnter = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnter?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragenter',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnter, editorActor, slateEditor],\n  )\n\n  const handleDragOver = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOver?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragover',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragOver, editorActor, slateEditor],\n  )\n\n  const handleDrop = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrop?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for drop event')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drop',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrop, editorActor, slateEditor],\n  )\n\n  const handleDragLeave = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeave?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragleave',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragLeave, editorActor, slateEditor],\n  )\n\n  if (!portableTextEditor) {\n    return null\n  }\n\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragEnd={handleDragEnd}\n      onDragEnter={handleDragEnter}\n      onDragOver={handleDragOver}\n      onDrop={handleDrop}\n      onDragLeave={handleDragLeave}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n"],"names":["EditorEventListener","props","$","_c","editor","useEditor","on","useEffectEvent","t0","subscription","unsubscribe","t1","useEffect","getCompoundClientRect","nodes","length","DOMRect","elements","filter","node","Element","firstRect","at","getBoundingClientRect","left","top","right","bottom","i","rect","Math","min","max","getDragSelection","eventSelection","snapshot","dragSelection","selectors","context","selection","draggingCollapsedSelection","draggedTextBlock","draggedSpan","anchor","utils","block","focus","selectedBlocks","selectionStartBlock","selectionEndBlock","selectionStartPoint","selectionEndPoint","getEventPosition","editorActor","slateEditor","event","getSnapshot","matches","setup","getEventNode","getNodeBlock","schema","positionBlock","getEventPositionBlock","getEventSelection","Editor","isEditor","path","_key","focusBlockPath","focusBlockKey","undefined","DOMEditor","hasTarget","target","toSlateNode","firstBlock","getFirstBlock","firstBlockRect","toDOMNode","pageY","lastBlock","getLastBlock","lastBlockRef","elementRect","height","abs","range","getSlateRangeFromEvent","slateRangeToSelection","isDOMNode","window","getWindow","domRange","document","caretPositionFromPoint","position","clientX","clientY","createRange","setStart","offsetNode","offset","setEnd","caretRangeFromPoint","console","warn","toSlateRange","exactMatch","suppressThrow","normalizePoint","point","value","newPath","newOffset","blockKey","childKey","find","blk","push","children","Array","isArray","child","cld","text","normalizeSelection","newAnchor","newFocus","isEqual","backward","getSelectionDomNodes","blockNodes","childNodes","blockEntries","from","mode","match","n","childEntries","isTextSpan","isBlock","map","blockNode","childNode","debug","debugWithName","EMPTY_MARKS","Leaf","attributes","leaf","schemaTypes","renderChild","renderDecorator","renderAnnotation","spanRef","useRef","portableTextEditor","usePortableTextEditor","blockSelected","useSelected","focused","setFocused","useState","selected","setSelected","parent","useMemo","decoratorValues","decorators","dec","marks","uniq","mark","includes","annotationMarks","annotations","markDefs","def","Boolean","shouldTrackSelectionAndFocus","sel","PortableTextEditor","getSelection","isCollapsedSelection","startTransition","setSelectedFromRange","useCallback","winSelection","rangeCount","getRangeAt","current","intersectsNode","onBlur","onFocus","onSelection","content","returnedChildren","Text","isText","_type","span","name","forEach","schemaType","_props","Object","defineProperty","editorElementRef","enumerable","get","annotation","t","_child","displayName","DropIndicator","Symbol","for","width","borderBottom","zIndex","RenderDefaultBlockObject","userSelect","blockObject","RenderDefaultInlineObject","inlineObject","createCoreBlockElementBehaviorsConfig","key","onSetDragPositionBlock","behavior","defineBehavior","guard","dropFocusBlock","dragOrigin","beta","internalDrag","origin","some","draggedBlock","actions","type","effect","priority","createEditorPriority","reference","corePriority","importance","forward","useCoreBlockElementBehaviors","useContext","EditorActorContext","t2","behaviorConfigs","behaviorConfig","send","behaviorConfig_0","RenderBlockObject","dragPositionBlock","setDragPositionBlock","blockObjectRef","useSlateStatic","element","legacySchemaType","useSelector","s","getLegacySchema","blockObjects","error","Range","isCollapsed","readOnly","renderBlock","RenderInlineObject","inlineObjectRef","inlineObjects","findPath","getPointBlock","display","RenderTextBlock","blockRef","legacySchema","legacyBlockSchemaType","renderStyle","textBlock","style","legacyStyleSchemaType","styles","renderListItem","listItem","legacyListItemSchemaType","lists","list","level","join","spellCheck","RenderElement","_temp","__inline","parseInlineObject","keyGenerator","_temp2","options","refreshKeys","parseTextBlock","_temp3","parseBlockObject","_temp4","t3","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","keys","cat","hotkey","Error","isHotkey","nativeEvent","preventDefault","possibleMark","behaviorEvent","decorator","possibleCommand","command","slateOperationCallback","input","sendBack","originalApply","apply","op","operation","rangeDecorationsMachine","types","events","assign","pendingRangeDecorations","rangeDecorations","decoratedRanges","rangeDecorationState","rangeDecoration","slateRange","isRange","onMoved","newSelection","decoratedRange","newRange","moveRangeByOperation","newRangeSelection","updateCount","actors","fromCallback","guards","has pending range decorations","has range decorations","has different decorations","existingRangeDecorations","newRangeDecorations","not read only","should skip setup","skipSetup","createMachine","id","invoke","src","initial","states","always","and","entry","createDecorate","rangeDecorationActor","isEqualToEmptyEditor","placeholder","isElement","blockIndex","_","childIndex","Path","equals","intersection","PLACEHOLDER_STYLE","pointerEvents","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onCut","onClick","onDragStart","onDrag","onDragEnd","onDragEnter","onDragOver","onDrop","onDragLeave","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","useSlate","rangeDecorationsActor","useActorRef","decorate","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","decoration","component","restoreSelectionFromProps","JSON","stringify","normalizedSelection","fromSlateValue","Transforms","select","operations","o","onChange","onReady","onInvalidValue","onValueChanged","handleCopy","clipboardData","stopPropagation","originEvent","dataTransfer","handleCut","handlePaste","KEY_TO_VALUE_ELEMENT","onPasteResult","Promise","resolve","then","result","insert","blocks","parseBlocks","placement","catch","finally","handleOnFocus","isDefaultPrevented","start","handleClick","isPropagationStopped","handleOnBlur","handleOnBeforeInput","validateSelection","root","ReactEditor","findDocumentOrShadowRoot","activeElement","domSelection","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","deselect","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","_editor","addEventListener","removeEventListener","handleDragStart","getEditorSnapshot","editorActorSnapshot","slateEditorInstance","selectingEntireBlocks","dragGhost","createElement","draggedDomNodes","clonedBlockNodes","cloneNode","HTMLElement","appendChild","customGhost","querySelector","replaceChildren","setAttribute","boxSizing","body","customGhostRect","x","y","setDragImage","blocksDomRect","clonedChildNodes","childrenDomRect","isSelectionCollapsed","getSelectionEndPoint","ghost","handleDrag","handleDragEnd","handleDragEnter","handleDragOver","handleDrop","handleDragLeave","SlateEditable","className"],"mappings":"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"}