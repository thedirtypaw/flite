{"version":3,"file":"selector.is-selecting-entire-blocks.js","sources":["../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.is-selection-collapsed.ts","../../src/selectors/selectors.ts","../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-selection-start-point.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-previous-inline-object.ts","../../src/selectors/selector.get-selected-slice.ts","../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.is-selection-expanded.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.get-selected-text-blocks.ts","../../src/selectors/selector.get-trimmed-selection.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts","../../src/selectors/selector.is-selecting-entire-blocks.ts"],"sourcesContent":["import type {KeyedSegment, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {isKeyedSegment} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }> = []\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlockKey = isKeyedSegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeyedSegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startSpanKey = isKeyedSegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endSpanKey = isKeyedSegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  let startBlockFound = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (startBlockFound) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(snapshot.context.selection.anchor.path) ===\n      JSON.stringify(snapshot.context.selection.focus.path) &&\n    snapshot.context.selection?.anchor.offset ===\n      snapshot.context.selection?.focus.offset\n  )\n}\n","import type {\n  KeyedSegment,\n  PortableTextBlock,\n  PortableTextListBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isListBlock, isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node)\n    ? {node: focusTextBlock.node, path: focusTextBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusTextBlock(snapshot)\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.focus.path[2])\n      ? snapshot.context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusSpan, getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const selectedSpans = getSelectedSpans(snapshot)\n  const focusSpan = getFocusSpan(snapshot)\n\n  if (selectedSpans.length === 0 || !focusSpan) {\n    return []\n  }\n\n  if (selectedSpans.length === 1 && isSelectionCollapsed(snapshot)) {\n    if (snapshot.context.selection.focus.offset === 0) {\n      return []\n    }\n    if (\n      snapshot.context.selection.focus.offset === focusSpan.node.text.length\n    ) {\n      return []\n    }\n  }\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isTextBlock(snapshot.context, block.node)\n      ? (block.node.markDefs ?? [])\n      : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    selectedSpans.some((span) => span.node.marks?.includes(markDef._key)),\n  )\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import type {EditorSelectionPoint} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import type {EditorSelectionPoint} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeySegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {sliceBlocks} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedSlice: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return sliceBlocks({\n    context: snapshot.context,\n    blocks: snapshot.context.value,\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedSlice} from './selector.get-selected-slice'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = (snapshot) => {\n  const selectedSlice = getSelectedSlice(snapshot)\n\n  return selectedSlice.reduce((text, block) => {\n    if (!isTextBlock(snapshot.context, block)) {\n      return text\n    }\n\n    return (\n      text +\n      block.children.reduce((text, child) => {\n        if (isSpan(snapshot.context, child)) {\n          return text + child.text\n        }\n\n        return text\n      }, '')\n    )\n  }, '')\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = (snapshot) => {\n  return !isSelectionCollapsed(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  getBlockEndPoint,\n  getBlockStartPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        context: snapshot.context,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import type {KeyedSegment, PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {isKeyedSegment} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: [KeyedSegment]}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: [KeyedSegment]\n  }> = []\n  const startKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedTextBlocks\n  }\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import type {PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {isEmptyTextBlock, isKeyedSegment} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getTrimmedSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return snapshot.context.selection\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot)\n  const endPoint = getSelectionEndPoint(snapshot)\n\n  if (!startPoint || !endPoint) {\n    return snapshot.context.selection\n  }\n\n  const startBlockKey = isKeyedSegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : null\n  const startChildKey = isKeyedSegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : null\n  const endBlockKey = isKeyedSegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : null\n  const endChildKey = isKeyedSegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : null\n\n  if (!startBlockKey || !endBlockKey) {\n    return snapshot.context.selection\n  }\n\n  let startBlockFound = false\n  let adjustedStartPoint: EditorSelectionPoint | undefined\n  let trimStartPoint = false\n  let adjustedEndPoint: EditorSelectionPoint | undefined\n  let trimEndPoint = false\n  let previousPotentialEndpoint:\n    | {blockKey: string; span: PortableTextSpan}\n    | undefined\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n\n      if (\n        isTextBlock(snapshot.context, block) &&\n        isEmptyTextBlock(snapshot.context, block)\n      ) {\n        continue\n      }\n    }\n\n    if (!startBlockFound) {\n      continue\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (\n      block._key === endBlockKey &&\n      isEmptyTextBlock(snapshot.context, block)\n    ) {\n      break\n    }\n\n    for (const child of block.children) {\n      if (child._key === endChildKey) {\n        if (!isSpan(snapshot.context, child) || endPoint.offset === 0) {\n          adjustedEndPoint = previousPotentialEndpoint\n            ? {\n                path: [\n                  {_key: previousPotentialEndpoint.blockKey},\n                  'children',\n                  {_key: previousPotentialEndpoint.span._key},\n                ],\n                offset: previousPotentialEndpoint.span.text.length,\n              }\n            : undefined\n\n          trimEndPoint = true\n          break\n        }\n      }\n\n      if (trimStartPoint) {\n        const lonelySpan =\n          isSpan(snapshot.context, child) && block.children.length === 1\n\n        if (\n          (isSpan(snapshot.context, child) && child.text.length > 0) ||\n          lonelySpan\n        ) {\n          adjustedStartPoint = {\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n            offset: 0,\n          }\n          previousPotentialEndpoint = {blockKey: block._key, span: child}\n          trimStartPoint = false\n        }\n\n        continue\n      }\n\n      if (child._key === startChildKey) {\n        if (!isSpan(snapshot.context, child)) {\n          trimStartPoint = true\n          continue\n        }\n\n        if (startPoint.offset === child.text.length) {\n          trimStartPoint = true\n          previousPotentialEndpoint =\n            child.text.length > 0\n              ? {blockKey: block._key, span: child}\n              : previousPotentialEndpoint\n          continue\n        }\n      }\n\n      previousPotentialEndpoint =\n        isSpan(snapshot.context, child) && child.text.length > 0\n          ? {blockKey: block._key, span: child}\n          : previousPotentialEndpoint\n    }\n\n    if (block._key === endBlockKey) {\n      break\n    }\n  }\n\n  const trimmedSelection = snapshot.context.selection.backward\n    ? {\n        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n        focus: adjustedStartPoint ?? startPoint,\n        backward: true,\n      }\n    : {\n        anchor: adjustedStartPoint ?? startPoint,\n        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n      }\n\n  if (\n    isSelectionCollapsed({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n  ) {\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n\n    if (\n      focusTextBlock &&\n      !isEmptyTextBlock(snapshot.context, focusTextBlock.node)\n    ) {\n      return null\n    }\n  }\n\n  return trimmedSelection\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusSpan, getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const focusSpan = getFocusSpan(snapshot)\n\n    const selectedSpans = isSelectionExpanded(snapshot)\n      ? getSelectedSpans(snapshot)\n      : focusSpan\n        ? [focusSpan]\n        : []\n\n    if (selectedSpans.length === 0) {\n      return false\n    }\n\n    if (\n      selectedSpans.some(\n        (span) => !span.node.marks || span.node.marks?.length === 0,\n      )\n    ) {\n      return false\n    }\n\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isTextBlock(snapshot.context, block.node)\n        ? (block.node.markDefs ?? [])\n        : [],\n    )\n\n    return selectedSpans.every((span) => {\n      const spanMarkDefs =\n        span.node.marks?.flatMap((mark) => {\n          const markDef = selectionMarkDefs.find(\n            (markDef) => markDef._key === mark,\n          )\n\n          return markDef ? [markDef._type] : []\n        }) ?? []\n\n      return spanMarkDefs.includes(annotation)\n    })\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    return snapshot.context.activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = utils.getBlockEndPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = utils.getBlockStartPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = snapshot.context.selection.backward\n      ? reverseSelection(snapshot.context.selection)\n      : snapshot.context.selection\n\n    const pointBlockKey = isKeyedSegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeyedSegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const endBlockKey = isKeyedSegment(selection.focus.path[0])\n      ? selection.focus.path[0]._key\n      : undefined\n    const endChildKey = isKeyedSegment(selection.focus.path[2])\n      ? selection.focus.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    let after = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = true\n          break\n        }\n\n        // Both the point and the selection end in this block\n\n        if (!isTextBlock(snapshot.context, block)) {\n          break\n        }\n\n        if (!pointChildKey || !endChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = true\n              break\n            }\n\n            // Both the point and the selection end in this child\n\n            after = point.offset > selection.focus.offset\n            break\n          }\n\n          if (child._key === pointChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === pointBlockKey) {\n        break\n      }\n    }\n\n    return after\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = snapshot.context.selection.backward\n      ? reverseSelection(snapshot.context.selection)\n      : snapshot.context.selection\n\n    const pointBlockKey = isKeyedSegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeyedSegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const startBlockKey = isKeyedSegment(selection.anchor.path[0])\n      ? selection.anchor.path[0]._key\n      : undefined\n    const startChildKey = isKeyedSegment(selection.anchor.path[2])\n      ? selection.anchor.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    let before = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = true\n          break\n        }\n\n        // Both the point and the selection start in this block\n\n        if (!isTextBlock(snapshot.context, block)) {\n          break\n        }\n\n        if (!pointChildKey || !startChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = true\n              break\n            }\n\n            // Both the point and the selection start in this child\n\n            before = point.offset < selection.anchor.offset\n            break\n          }\n\n          if (child._key === startChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === startBlockKey) {\n        break\n      }\n    }\n\n    return before\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from '../utils'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    const originalSelectionStartPoint = getSelectionStartPoint(snapshot)\n    const originalSelectionEndPoint = getSelectionEndPoint(snapshot)\n\n    if (\n      !selectionStartPoint ||\n      !selectionEndPoint ||\n      !originalSelectionStartPoint ||\n      !originalSelectionEndPoint\n    ) {\n      return false\n    }\n\n    const startPointBeforeSelection =\n      isPointBeforeSelection(selectionStartPoint)(snapshot)\n    const startPointAfterSelection =\n      isPointAfterSelection(selectionStartPoint)(snapshot)\n    const endPointBeforeSelection =\n      isPointBeforeSelection(selectionEndPoint)(snapshot)\n    const endPointAfterSelection =\n      isPointAfterSelection(selectionEndPoint)(snapshot)\n\n    const originalStartPointBeforeStartPoint = isPointBeforeSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n    const originalStartPointAfterStartPoint = isPointAfterSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n\n    const originalEndPointBeforeEndPoint = isPointBeforeSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n    const originalEndPointAfterEndPoint = isPointAfterSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n\n    const endPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionStartPoint,\n    )\n    const startPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionEndPoint,\n    )\n\n    if (endPointBeforeSelection && !endPointEqualToOriginalStartPoint) {\n      return false\n    }\n\n    if (startPointAfterSelection && !startPointEqualToOriginalEndPoint) {\n      return false\n    }\n\n    if (\n      !originalStartPointBeforeStartPoint &&\n      originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      originalEndPointAfterEndPoint\n    ) {\n      return !endPointEqualToOriginalStartPoint\n    }\n\n    if (\n      originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return !startPointEqualToOriginalEndPoint\n    }\n\n    if (\n      !startPointAfterSelection ||\n      !startPointBeforeSelection ||\n      !endPointAfterSelection ||\n      !endPointBeforeSelection\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {getSelectionEndBlock, getSelectionStartBlock} from './selectors'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = utils.getBlockStartPoint({\n    context: snapshot.context,\n    block: startBlock,\n  })\n  const endBlockEndPoint = utils.getBlockEndPoint({\n    context: snapshot.context,\n    block: endBlock,\n  })\n\n  return (\n    utils.isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    utils.isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n"],"names":["getSelectedSpans","snapshot","context","selection","selectedSpans","startPoint","backward","focus","anchor","endPoint","startBlockKey","isKeyedSegment","path","_key","undefined","endBlockKey","startSpanKey","endSpanKey","startBlockFound","block","value","isTextBlock","child","children","isSpan","offset","text","length","push","node","isSelectionCollapsed","JSON","stringify","getFocusBlock","key","find","getFocusListBlock","focusTextBlock","getFocusTextBlock","isListBlock","focusBlock","getFocusBlockObject","getFocusChild","span","getFocusSpan","focusChild","getFirstBlock","getLastBlock","getSelectedBlocks","selectedBlocks","startKey","endKey","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock","getActiveAnnotations","focusSpan","flatMap","markDefs","filter","markDef","some","marks","includes","getActiveListItem","selectedTextBlocks","map","firstTextBlock","at","firstListItem","listItem","every","getActiveStyle","firstStyle","style","getSelectionEndPoint","getSelectionStartPoint","getNextInlineObject","selectionEndPoint","selectionEndPointChildKey","isKeySegment","endPointChildFound","inlineObject","getPreviousInlineObject","selectionStartPoint","selectionStartPointChildKey","getSelectedSlice","sliceBlocks","blocks","getSelectionText","reduce","isSelectionExpanded","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","split","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","caretWordEndSelectionPoint","caretWordSelection","getSelectedTextBlocks","getTrimmedSelection","startChildKey","endChildKey","adjustedStartPoint","trimStartPoint","adjustedEndPoint","trimEndPoint","previousPotentialEndpoint","isEmptyTextBlock","blockKey","lonelySpan","trimmedSelection","isActiveAnnotation","annotation","selectionMarkDefs","mark","_type","isActiveDecorator","decorator","activeDecorators","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","utils","isAtTheStartOfBlock","isPointAfterSelection","point","reverseSelection","pointBlockKey","pointChildKey","after","isPointBeforeSelection","before","isOverlappingSelection","originalSelectionStartPoint","originalSelectionEndPoint","startPointBeforeSelection","startPointAfterSelection","endPointBeforeSelection","endPointAfterSelection","originalStartPointBeforeStartPoint","originalStartPointAfterStartPoint","originalEndPointBeforeEndPoint","originalEndPointAfterEndPoint","endPointEqualToOriginalStartPoint","isEqualSelectionPoints","startPointEqualToOriginalEndPoint","isSelectingEntireBlocks","startBlock","endBlock","startBlockStartPoint","endBlockEndPoint"],"mappings":"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"}