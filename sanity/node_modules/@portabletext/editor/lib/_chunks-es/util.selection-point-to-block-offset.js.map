{"version":3,"file":"util.selection-point-to-block-offset.js","sources":["../../src/utils/util.block-offset-to-block-selection-point.ts","../../src/utils/util.block-offset-to-selection-point.ts","../../src/utils/util.block-offsets-to-selection.ts","../../src/utils/util.child-selection-point-to-block-offset.ts","../../src/utils/util.get-selection-end-point.ts","../../src/utils/util.get-selection-start-point.ts","../../src/utils/util.selection-point-to-block-offset.ts"],"sourcesContent":["import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function blockOffsetToBlockSelectionPoint({\n  context,\n  blockOffset,\n}: {\n  context: Pick<EditorContext, 'value'>\n  blockOffset: BlockOffset\n}): EditorSelectionPoint | undefined {\n  let selectionPoint: EditorSelectionPoint | undefined\n\n  for (const block of context.value) {\n    if (block._key === blockOffset.path[0]._key) {\n      selectionPoint = {\n        path: [{_key: block._key}],\n        offset: blockOffset.offset,\n      }\n      break\n    }\n  }\n\n  return selectionPoint\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {blockOffsetToSpanSelectionPoint} from './util.block-offset'\nimport {blockOffsetToBlockSelectionPoint} from './util.block-offset-to-block-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetToSelectionPoint({\n  context,\n  blockOffset,\n  direction,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}): EditorSelectionPoint | undefined {\n  const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context,\n    blockOffset,\n    direction,\n  })\n\n  if (!spanSelectionPoint) {\n    return blockOffsetToBlockSelectionPoint({\n      context,\n      blockOffset,\n    })\n  }\n\n  return spanSelectionPoint\n}\n","import type {EditorSelection} from '..'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport {blockOffsetToSelectionPoint} from './util.block-offset-to-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetsToSelection({\n  context,\n  offsets,\n  backward,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  offsets: {anchor: BlockOffset; focus: BlockOffset}\n  backward?: boolean\n}): EditorSelection {\n  const anchor = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.anchor,\n    direction: backward ? 'backward' : 'forward',\n  })\n  const focus = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.focus,\n    direction: backward ? 'forward' : 'backward',\n  })\n\n  if (!anchor || !focus) {\n    return null\n  }\n\n  return {\n    anchor,\n    focus,\n    backward,\n  }\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function childSelectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const childKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !childKey) {\n    return undefined\n  }\n\n  for (const block of context.value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (child._key === childKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      if (isSpan(context, child)) {\n        offset += child.text.length\n      }\n    }\n  }\n}\n","import type {EditorSelection, EditorSelectionPoint} from '..'\n\n/**\n * @public\n */\nexport function getSelectionEndPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends\n    EditorSelectionPoint | null = TEditorSelection extends NonNullable<EditorSelection>\n    ? EditorSelectionPoint\n    : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.anchor : selection.focus\n  ) as TEditorSelectionPoint\n}\n","import type {EditorSelection, EditorSelectionPoint} from '..'\n\n/**\n * @public\n */\nexport function getSelectionStartPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends\n    EditorSelectionPoint | null = TEditorSelection extends NonNullable<EditorSelection>\n    ? EditorSelectionPoint\n    : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.focus : selection.anchor\n  ) as TEditorSelectionPoint\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {childSelectionPointToBlockOffset} from './util.child-selection-point-to-block-offset'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function selectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  if (\n    selectionPoint.path.length === 1 &&\n    isKeyedSegment(selectionPoint.path[0])\n  ) {\n    return {\n      path: [{_key: selectionPoint.path[0]._key}],\n      offset: selectionPoint.offset,\n    }\n  }\n\n  return childSelectionPointToBlockOffset({\n    context,\n    selectionPoint,\n  })\n}\n"],"names":["blockOffsetToBlockSelectionPoint","context","blockOffset","selectionPoint","block","value","_key","path","offset","blockOffsetToSelectionPoint","direction","blockOffsetToSpanSelectionPoint","blockOffsetsToSelection","offsets","backward","anchor","focus","childSelectionPointToBlockOffset","blockKey","isKeyedSegment","undefined","childKey","isTextBlock","child","children","isSpan","text","length","getSelectionEndPoint","selection","getSelectionStartPoint","selectionPointToBlockOffset"],"mappings":";AAOO,SAASA,iCAAiC;AAAA,EAC/CC;AAAAA,EACAC;AAIF,GAAqC;AAC/BC,MAAAA;AAEJ,aAAWC,SAASH,QAAQI;AAC1B,QAAID,MAAME,SAASJ,YAAYK,KAAK,CAAC,EAAED,MAAM;AAC1B,uBAAA;AAAA,QACfC,MAAM,CAAC;AAAA,UAACD,MAAMF,MAAME;AAAAA,QAAAA,CAAK;AAAA,QACzBE,QAAQN,YAAYM;AAAAA,MACtB;AACA;AAAA,IAAA;AAIGL,SAAAA;AACT;AClBO,SAASM,4BAA4B;AAAA,EAC1CR;AAAAA,EACAC;AAAAA,EACAQ;AAKF,GAAqC;AAOnC,SAN2BC,gCAAgC;AAAA,IACzDV;AAAAA,IACAC;AAAAA,IACAQ;AAAAA,EAAAA,CACD,KAGQV,iCAAiC;AAAA,IACtCC;AAAAA,IACAC;AAAAA,EAAAA,CACD;AAIL;ACxBO,SAASU,wBAAwB;AAAA,EACtCX;AAAAA,EACAY;AAAAA,EACAC;AAKF,GAAoB;AAClB,QAAMC,SAASN,4BAA4B;AAAA,IACzCR;AAAAA,IACAC,aAAaW,QAAQE;AAAAA,IACrBL,WAAWI,WAAW,aAAa;AAAA,EAAA,CACpC,GACKE,QAAQP,4BAA4B;AAAA,IACxCR;AAAAA,IACAC,aAAaW,QAAQG;AAAAA,IACrBN,WAAWI,WAAW,YAAY;AAAA,EAAA,CACnC;AAED,SAAI,CAACC,UAAU,CAACC,QACP,OAGF;AAAA,IACLD;AAAAA,IACAC;AAAAA,IACAF;AAAAA,EACF;AACF;AC5BO,SAASG,iCAAiC;AAAA,EAC/ChB;AAAAA,EACAE;AAIF,GAA4B;AAC1B,MAAIK,SAAS;AAEPU,QAAAA,WAAWC,eAAehB,eAAeI,KAAK,CAAC,CAAC,IAClDJ,eAAeI,KAAK,CAAC,EAAED,OACvBc,QACEC,WAAWF,eAAehB,eAAeI,KAAK,CAAC,CAAC,IAClDJ,eAAeI,KAAK,CAAC,EAAED,OACvBc;AAEA,MAAA,EAAA,CAACF,YAAY,CAACG;AAIlB,eAAWjB,SAASH,QAAQI;AAC1B,UAAID,MAAME,SAASY,YAIdI,YAAYrB,SAASG,KAAK;AAIpBmB,mBAAAA,SAASnB,MAAMoB,UAAU;AAClC,cAAID,MAAMjB,SAASe;AACV,mBAAA;AAAA,cACLd,MAAM,CAAC;AAAA,gBAACD,MAAMF,MAAME;AAAAA,cAAAA,CAAK;AAAA,cACzBE,QAAQA,SAASL,eAAeK;AAAAA,YAClC;AAGEiB,iBAAOxB,SAASsB,KAAK,MACvBf,UAAUe,MAAMG,KAAKC;AAAAA,QAAAA;AAAAA;AAI7B;AC9CO,SAASC,qBAMdC,WAAoD;AACpD,SAAKA,YAKHA,UAAUf,WAAWe,UAAUd,SAASc,UAAUb,QAJ3C;AAMX;ACdO,SAASc,uBAMdD,WAAoD;AACpD,SAAKA,YAKHA,UAAUf,WAAWe,UAAUb,QAAQa,UAAUd,SAJ1C;AAMX;ACVO,SAASgB,4BAA4B;AAAA,EAC1C9B;AAAAA,EACAE;AAIF,GAA4B;AAExBA,SAAAA,eAAeI,KAAKoB,WAAW,KAC/BR,eAAehB,eAAeI,KAAK,CAAC,CAAC,IAE9B;AAAA,IACLA,MAAM,CAAC;AAAA,MAACD,MAAMH,eAAeI,KAAK,CAAC,EAAED;AAAAA,IAAAA,CAAK;AAAA,IAC1CE,QAAQL,eAAeK;AAAAA,MAIpBS,iCAAiC;AAAA,IACtChB;AAAAA,IACAE;AAAAA,EAAAA,CACD;AACH;"}